From c92ad04556a0b319acc798a8499aa42b6bd766c2 Mon Sep 17 00:00:00 2001
From: John Fastabend <john.r.fastabend@intel.com>
Date: Mon, 8 Jul 2013 12:12:08 -0700
Subject: [PATCH] lldpad: do not require active TLVs to configure attributes

No longer require TLV data structures to be initialized to read/write
configuration. This allows managing ports before link is established.

In this patch we update the command handlers to read the config file
on gets which works because sets keep the config file in sync. The set
operations are updated by removing the requirement of existing data
structures. If the data structure is not available yet the config value
is written to the configuration file only.

Because the sets may occur before ifup() any checks for valid ports
must be done in the set handler path. For 8021qaz this means verifying
the port supports DCB.

The VDP mode attribute is AFAIK the only attribute that can not
be set or queried before ifup(). This is because the mode values are
not stored in the config file. This is left for future work if the
VDP mode values need to be configured prior to ifup(). At this time
I'm not sure this would be useful.

One other change is attributes without values in the config file
will be left blank when displayed with the '-c' option. I believe this
is more in spirit with the intent of the option. One example here
given on a tap device that has not been brought online yet and has
no capabilities configuration value.

# ./lldptool -t -g ncb -i tap0 -V EVBcfg -c
fmode=bridge
capabilities=
vsis=3295
rte=15
enableTx=no

I tested many of the 8021qaz, dcbtool, VDP, and EVB commands along
with some of the other TLV types.

Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
---
 lldp_8021qaz.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/lldp_8021qaz.c b/lldp_8021qaz.c
index b3da01b..fb7843c 100644
--- a/lldp_8021qaz.c
+++ b/lldp_8021qaz.c
@@ -492,6 +492,7 @@ static int get_dcbx_hw(const char *ifname, __u8 *dcbx)
 	if (!attr) {
 		LLDPAD_DBG("%s: %s: nlmsg_find_attr failed, no GDCBX support\n",
 			    __func__, ifname);
+		err = -EOPNOTSUPP;
 		goto out;
 	}
 
@@ -540,8 +541,7 @@ void ieee8021qaz_ifup(char *ifname, struct lldp_agent *agent)
 	/* If hardware is not DCBX IEEE compliant or it is managed
 	 * by an LLD agent most likely a firmware agent abort
 	 */
-	if (!(dcbx & DCB_CAP_DCBX_VER_IEEE) ||
-	    (dcbx & DCB_CAP_DCBX_LLD_MANAGED))
+	if (dcbx & DCB_CAP_DCBX_LLD_MANAGED)
 		return;
 
 	/* If 802.1Qaz is already configured no need to continue */
@@ -633,8 +633,10 @@ initialized:
 	/* Query hardware and set maximum number of TCs with hardware values */
 	len = get_ieee_hw(ifname, &ets, &pfc, &data, &cnt);
 	if (len > 0) {
-		tlvs->ets->cfgl->max_tcs = ets->ets_cap;
-		tlvs->pfc->local.pfc_cap = pfc->pfc_cap;
+		if (ets)
+			tlvs->ets->cfgl->max_tcs = ets->ets_cap;
+		if (pfc)
+			tlvs->pfc->local.pfc_cap = pfc->pfc_cap;
 
 		free(ets);
 		free(pfc);
@@ -644,7 +646,7 @@ initialized:
 	/* if the dcbx field is filled in by the dcbx query then the
 	 * kernel is supports IEEE mode, so make IEEE DCBX active by default.
 	 */
-	if (!dcbx || (dcbx_get_legacy_version(ifname) & ~MASK_DCBX_FORCE)) {
+	if (dcbx_get_legacy_version(ifname) & ~MASK_DCBX_FORCE) {
 		tlvs->active = false;
 	} else {
 		tlvs->active = true;
-- 
1.9.3

